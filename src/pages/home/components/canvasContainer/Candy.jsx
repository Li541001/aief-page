/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef } from "react";
import { useGLTF, useScroll } from "@react-three/drei";
import { useFrame,useLoader } from "@react-three/fiber";
import * as THREE from "three";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";

export function Candy(props) {
  const group = useRef();
  const leaf = useRef();
  const scroll = useScroll();
  const {nodes,materials} = useLoader(GLTFLoader, './candy.glb')
  const userHeight = window.innerWidth;

  useFrame((state, delta) => {
    const range1 = scroll.range(2 / 36, 4 / 36);
    const isRange1 = scroll.visible(0 / 36, 6 / 36);
    const range2 = scroll.range(11 / 36, 3 / 36);
    const isRange2 = scroll.visible(8 / 36, 8 / 36);
    const range3 = scroll.range(16 / 36, 4 / 36);
    const isRange3 = scroll.visible(14 / 36, 12 / 36);
    const range4 = scroll.range(20 / 36, 2 / 36);
    const isRange4 = scroll.visible(14 / 36, 12 / 36);
    const range5 = scroll.range(26 / 36, 4 / 36);
    const isRange5 = scroll.visible(22 / 36, 12 / 36);
    const range6 = scroll.range(32 / 36, 2 / 36);
    const isRange6 = scroll.visible(30 / 36, 6 / 36);

    const isRange7 = scroll.visible(35 / 36, 4 / 36);
    if ((isRange2 == false) & (isRange3 == false)) {
      group.current.rotation.y =
        Math.cos(state.clock.getElapsedTime() * 1.2) * 0.05 + 1.4;
    }
    if (isRange6) {
      group.current.position.x = THREE.MathUtils.damp(
        group.current.position.x,
        -(userHeight / 10000) * range6,
        5,
        delta
      );
      group.current.position.y = THREE.MathUtils.damp(
        group.current.position.y,
        -(userHeight / 10000) * range6,
        5,
        delta
      );

      group.current.scale.x = THREE.MathUtils.damp(
        group.current.scale.x,
        0.2 * (1 - range6) + 0.8,
        5,
        delta
      );
      group.current.scale.y = THREE.MathUtils.damp(
        group.current.scale.y,
        0.2 * (1 - range6) + 0.8,
        5,
        delta
      );
      group.current.scale.z = THREE.MathUtils.damp(
        group.current.scale.z,
        0.2 * (1 - range6) + 0.8,
        5,
        delta
      );
      leaf.current.rotation.x += (Math.PI / 5) * 1;
    } /*
    if(isRange5){
      group.current.scale.x = THREE.MathUtils.damp(group.current.scale.x,1,5,delta)
      group.current.scale.y = THREE.MathUtils.damp(group.current.scale.y,1,5,delta)
      group.current.scale.z = THREE.MathUtils.damp(group.current.scale.z,1,5,delta)
    }*/
    if (isRange5) {
      leaf.current.rotation.x += (Math.PI / 5) * range5;
    }
    if (isRange4) {
      group.current.position.x = THREE.MathUtils.damp(
        group.current.position.x,
        -(userHeight / 4500) * (1 - range4),
        5,
        delta
      );
    }
    if (isRange3) {
      group.current.rotation.y = THREE.MathUtils.damp(
        group.current.rotation.y,
        (-Math.PI / 1.6) * (1 - range3) + 1.4,
        2,
        delta
      );
    }
    if (isRange2) {
      group.current.rotation.y = THREE.MathUtils.damp(
        group.current.rotation.y,
        (-Math.PI / 1.6) * range2 + 1.4,
        2,
        delta
      );
    }
    if (isRange1) {
      group.current.position.x = THREE.MathUtils.damp(
        group.current.position.x,
        -(userHeight / 4500) * range1,
        5,
        delta
      );
    }
    /*console.log(group.current.scale.z )*/
    if (isRange7) {
      props.button_ref1.current.className =
        "button_container button_action button_action1";
      props.button_ref2.current.className =
        "button_container button_action button_action2";
    } else {
      props.button_ref1.current.className = "button_container button_action1";
      props.button_ref2.current.className = "button_container button_action2";
    }
  });

  return (
    <group {...props} dispose={null} ref={group}>
      <group position={[0, -1.05, 0.3]} scale={0.05}>
        <group>
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.實體1_1.geometry}
            material={
              materials.XID_Generic_FEDF6FC922D6480B8D746BA033FD17DE_shader
            }
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.實體1_2.geometry}
            material={
              materials.XID_SmoothIvory_8E218EF9A12249BBBF73EA07F75B128E_shader
            }
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.實體1_3.geometry}
            material={materials.XID_1_2B0C168095F34958A480781CFBEAEC0F_shader}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.實體1_4.geometry}
            material={materials.XID_7_D684A87E2AAB4B458D5888421C4DB64D_shader}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.實體1_5.geometry}
            material={materials.XID_2_8B03BEC5BEF84CD79BC88E76B190F586_shader}
          />
          <mesh
            castShadow
            receiveShadow
            geometry={nodes.實體1_6.geometry}
            material={materials.XID_5_87A645862E514237837A47DFDC0788A8_shader}
          />
        </group>
      </group>
      <group
        position={[-0.35, -0.7, 0.14]}
        rotation={[-1.86, 0, Math.PI / 2]}
        ref={leaf}
      >
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.實體5.geometry}
          material={materials.XID_Clear_36F3453CFA954A44A49D4A3E1614CF86_shader}
          scale={0.06}
        />
      </group>
      <group position={[0.3, -1, 0]} rotation={[-1.34, -1.34, -Math.PI / 2]}>
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Sólido1.geometry}
          material={
            materials.XID_SmoothBlack_FF1D0FA62EB4454BAF87F3629FC0A678_shader
          }
          scale={0.02}
        />
      </group>
    </group>
  );
}


